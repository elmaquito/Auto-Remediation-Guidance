# Vulnerability-Assessment.ps1
# Comprehensive vulnerability assessment for Windows 11 systems
# Identifies security vulnerabilities and provides remediation guidance

[CmdletBinding()]
param(
    [switch]$WhatIf,
    [switch]$AutoRemediate,
    [switch]$DetailedScan,
    [string]$ReportPath = "$env:TEMP\VulnerabilityAssessment_$(Get-Date -Format 'yyyyMMdd_HHmmss').html",
    [string]$LogPath = "$env:TEMP\VulnerabilityAssessment.log",
    [ValidateSet("Critical", "High", "Medium", "Low", "All")]
    [string]$MinimumSeverity = "Medium"
)

# Initialize logging
function Write-VulnLog {
    param(
        [string]$Message,
        [string]$Level = "INFO",
        [string]$Category = "VULN"
    )
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
    $logEntry = "[$timestamp] [$Level] [$Category] $Message"
    $color = switch ($Level) {
        "ERROR" { "Red" }
        "WARNING" { "Yellow" }
        "SUCCESS" { "Green" }
        "CRITICAL" { "Magenta" }
        default { "White" }
    }
    Write-Host $logEntry -ForegroundColor $color
    Add-Content -Path $LogPath -Value $logEntry -ErrorAction SilentlyContinue
}

# Vulnerability storage
$script:Vulnerabilities = @()
$script:RemediationActions = @()

function Add-Vulnerability {
    param(
        [string]$Category,
        [string]$VulnID,
        [string]$Title,
        [string]$Severity,
        [string]$Description,
        [string]$Impact,
        [string]$Solution,
        [bool]$CanAutoRemediate = $false,
        [scriptblock]$RemediationAction = $null,
        [hashtable]$Details = @{}
    )
    
    $vuln = [PSCustomObject]@{
        Timestamp = Get-Date
        Category = $Category
        VulnID = $VulnID
        Title = $Title
        Severity = $Severity
        Description = $Description
        Impact = $Impact
        Solution = $Solution
        CanAutoRemediate = $CanAutoRemediate
        RemediationAction = $RemediationAction
        Details = $Details
    }
    
    $script:Vulnerabilities += $vuln
    Write-VulnLog "VULNERABILITY: [$Severity] $Category - $Title" $Level $Category
}

# Check for unpatched Windows vulnerabilities
function Test-WindowsVulnerabilities {
    Write-VulnLog "Checking for Windows vulnerabilities" "INFO" "WINDOWS"
    
    try {
        # Get Windows version info
        $osVersion = Get-CimInstance Win32_OperatingSystem
        $windowsVersion = $osVersion.Version
        $buildNumber = $osVersion.BuildNumber
        
        Write-VulnLog "Windows Version: $($osVersion.Caption) Build $buildNumber" "INFO" "WINDOWS"
        
        # Check for outdated Windows 11 builds
        if ($buildNumber -lt 22000) {
            Add-Vulnerability -Category "WINDOWS" -VulnID "WIN-001" -Title "Unsupported Windows Version" -Severity "Critical" `
                -Description "System is not running Windows 11" `
                -Impact "Missing latest security features and updates" `
                -Solution "Upgrade to Windows 11"
        } elseif ($buildNumber -lt 22621) {
            Add-Vulnerability -Category "WINDOWS" -VulnID "WIN-002" -Title "Outdated Windows 11 Build" -Severity "High" `
                -Description "Running an older Windows 11 build" `
                -Impact "Missing recent security patches and features" `
                -Solution "Install latest Windows 11 updates"
        }
        
        # Check Windows Update service
        $wuService = Get-Service -Name "wuauserv" -ErrorAction SilentlyContinue
        if ($wuService.Status -ne "Running") {
            Add-Vulnerability -Category "WINDOWS" -VulnID "WIN-003" -Title "Windows Update Service Disabled" -Severity "High" `
                -Description "Windows Update service is not running" `
                -Impact "System cannot receive security updates" `
                -Solution "Enable and start Windows Update service" `
                -CanAutoRemediate $true `
                -RemediationAction { Start-Service -Name "wuauserv"; Set-Service -Name "wuauserv" -StartupType Automatic }
        }
        
        # Check for pending updates using WMI
        $updateSession = New-Object -ComObject Microsoft.Update.Session
        $updateSearcher = $updateSession.CreateUpdateSearcher()
        try {
            $searchResult = $updateSearcher.Search("IsInstalled=0")
            $pendingUpdates = $searchResult.Updates
            
            if ($pendingUpdates.Count -gt 0) {
                $securityUpdates = 0
                $criticalUpdates = 0
                
                foreach ($update in $pendingUpdates) {
                    if ($update.MsrcSeverity -eq "Critical") { $criticalUpdates++ }
                    if ($update.Categories | Where-Object { $_.Name -eq "Security Updates" }) { $securityUpdates++ }
                }
                
                if ($criticalUpdates -gt 0) {
                    Add-Vulnerability -Category "WINDOWS" -VulnID "WIN-004" -Title "Critical Security Updates Pending" -Severity "Critical" `
                        -Description "$criticalUpdates critical security updates are pending installation" `
                        -Impact "System vulnerable to known critical security flaws" `
                        -Solution "Install critical security updates immediately"
                }
                
                if ($securityUpdates -gt 0) {
                    Add-Vulnerability -Category "WINDOWS" -VulnID "WIN-005" -Title "Security Updates Pending" -Severity "High" `
                        -Description "$securityUpdates security updates are pending installation" `
                        -Impact "System vulnerable to known security issues" `
                        -Solution "Install security updates"
                }
            }
        }
        catch {
            Write-VulnLog "Could not check for pending updates: $($_.Exception.Message)" "WARNING" "WINDOWS"
        }
        
        Write-VulnLog "Windows vulnerability check completed" "SUCCESS" "WINDOWS"
    }
    catch {
        Write-VulnLog "Error checking Windows vulnerabilities: $($_.Exception.Message)" "ERROR" "WINDOWS"
    }
}

# Check for vulnerable software installations
function Test-SoftwareVulnerabilities {
    Write-VulnLog "Checking for vulnerable software installations" "INFO" "SOFTWARE"
    
    try {
        # Get installed software
        $installedSoftware = Get-CimInstance -ClassName Win32_Product -ErrorAction SilentlyContinue
        
        # Known vulnerable software patterns (examples)
        $vulnerableSoftware = @{
            "Adobe Flash Player" = @{
                Severity = "Critical"
                Description = "Adobe Flash Player has known critical vulnerabilities"
                Solution = "Uninstall Adobe Flash Player immediately"
            }
            "Java.*1\.8\.0_[0-2][0-9][0-9]" = @{
                Severity = "High"
                Description = "Outdated Java version with known vulnerabilities"
                Solution = "Update Java to the latest version"
            }
            "Internet Explorer" = @{
                Severity = "Medium"
                Description = "Internet Explorer is deprecated and unsupported"
                Solution = "Use Microsoft Edge or other modern browsers"
            }
        }
        
        foreach ($software in $installedSoftware) {
            foreach ($vulnPattern in $vulnerableSoftware.Keys) {
                if ($software.Name -match $vulnPattern) {
                    $vulnInfo = $vulnerableSoftware[$vulnPattern]
                    Add-Vulnerability -Category "SOFTWARE" -VulnID "SW-$($vulnerableSoftware.Keys.IndexOf($vulnPattern) + 1)" -Title "Vulnerable Software: $($software.Name)" -Severity $vulnInfo.Severity `
                        -Description $vulnInfo.Description `
                        -Impact "Known security vulnerabilities in installed software" `
                        -Solution $vulnInfo.Solution `
                        -Details @{ SoftwareName = $software.Name; Version = $software.Version }
                }
            }
        }
        
        # Check for outdated browsers
        $browsers = @(
            @{ Name = "Google Chrome"; RegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\chrome.exe"; VersionKey = "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\Google Chrome" },
            @{ Name = "Mozilla Firefox"; RegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\firefox.exe"; VersionKey = "HKLM:\SOFTWARE\Mozilla\Mozilla Firefox" },
            @{ Name = "Microsoft Edge"; RegPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\msedge.exe"; VersionKey = "HKLM:\SOFTWARE\Microsoft\Edge\BLBeacon" }
        )
        
        foreach ($browser in $browsers) {
            $browserPath = Get-ItemProperty -Path $browser.RegPath -ErrorAction SilentlyContinue
            if ($browserPath) {
                try {
                    $versionInfo = Get-ItemProperty -Path $browser.VersionKey -ErrorAction SilentlyContinue
                    if ($versionInfo) {
                        # Simple version check (would need more sophisticated logic for real-world use)
                        Write-VulnLog "Found $($browser.Name) - Version check needed" "INFO" "SOFTWARE"
                    }
                }
                catch {
                    Write-VulnLog "Could not determine version for $($browser.Name)" "WARNING" "SOFTWARE"
                }
            }
        }
        
        Write-VulnLog "Software vulnerability check completed" "SUCCESS" "SOFTWARE"
    }
    catch {
        Write-VulnLog "Error checking software vulnerabilities: $($_.Exception.Message)" "ERROR" "SOFTWARE"
    }
}

# Check for weak cryptographic configurations
function Test-CryptographicVulnerabilities {
    Write-VulnLog "Checking cryptographic configurations" "INFO" "CRYPTO"
    
    try {
        # Check SSL/TLS settings
        $sslRegPath = "HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols"
        
        # Check for weak protocols
        $weakProtocols = @("SSL 2.0", "SSL 3.0", "TLS 1.0", "TLS 1.1")
        foreach ($protocol in $weakProtocols) {
            $protocolPath = Join-Path $sslRegPath $protocol
            $serverPath = Join-Path $protocolPath "Server"
            $clientPath = Join-Path $protocolPath "Client"
            
            $serverEnabled = Get-ItemProperty -Path $serverPath -Name "Enabled" -ErrorAction SilentlyContinue
            $clientEnabled = Get-ItemProperty -Path $clientPath -Name "Enabled" -ErrorAction SilentlyContinue
            
            if (($serverEnabled -and $serverEnabled.Enabled -eq 1) -or ($clientEnabled -and $clientEnabled.Enabled -eq 1)) {
                $severity = if ($protocol -in @("SSL 2.0", "SSL 3.0")) { "Critical" } else { "High" }
                Add-Vulnerability -Category "CRYPTO" -VulnID "CRY-001" -Title "Weak Protocol Enabled: $protocol" -Severity $severity `
                    -Description "$protocol is enabled and contains known vulnerabilities" `
                    -Impact "Vulnerable to man-in-the-middle attacks and data interception" `
                    -Solution "Disable $protocol in system configuration" `
                    -CanAutoRemediate $true `
                    -RemediationAction { 
                        if (Test-Path $serverPath) { Set-ItemProperty -Path $serverPath -Name "Enabled" -Value 0 }
                        if (Test-Path $clientPath) { Set-ItemProperty -Path $clientPath -Name "Enabled" -Value 0 }
                    }
            }
        }
        
        # Check cipher suites
        $cipherSuites = Get-TlsCipherSuite -ErrorAction SilentlyContinue
        if ($cipherSuites) {
            $weakCiphers = $cipherSuites | Where-Object { 
                $_.Name -match "NULL|EXPORT|DES|RC4|MD5" -or 
                ($_.CipherAlgorithm -eq "DES" -or $_.CipherAlgorithm -eq "3DES") -or
                $_.HashAlgorithm -eq "MD5"
            }
            
            foreach ($cipher in $weakCiphers) {
                Add-Vulnerability -Category "CRYPTO" -VulnID "CRY-002" -Title "Weak Cipher Suite: $($cipher.Name)" -Severity "Medium" `
                    -Description "Weak cryptographic cipher suite is enabled" `
                    -Impact "Potential for cryptographic attacks" `
                    -Solution "Disable weak cipher suites and use only strong modern ciphers"
            }
        }
        
        Write-VulnLog "Cryptographic vulnerability check completed" "SUCCESS" "CRYPTO"
    }
    catch {
        Write-VulnLog "Error checking cryptographic vulnerabilities: $($_.Exception.Message)" "ERROR" "CRYPTO"
    }
}

# Check for privilege escalation vulnerabilities
function Test-PrivilegeEscalationVulnerabilities {
    Write-VulnLog "Checking for privilege escalation vulnerabilities" "INFO" "PRIVESC"
    
    try {
        # Check for AlwaysInstallElevated
        $hklmValue = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name "AlwaysInstallElevated" -ErrorAction SilentlyContinue
        $hkcuValue = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name "AlwaysInstallElevated" -ErrorAction SilentlyContinue
        
        if (($hklmValue -and $hklmValue.AlwaysInstallElevated -eq 1) -and ($hkcuValue -and $hkcuValue.AlwaysInstallElevated -eq 1)) {
            Add-Vulnerability -Category "PRIVESC" -VulnID "PE-001" -Title "AlwaysInstallElevated Enabled" -Severity "High" `
                -Description "AlwaysInstallElevated policy is enabled, allowing privilege escalation" `
                -Impact "Any user can install MSI packages with elevated privileges" `
                -Solution "Disable AlwaysInstallElevated policy" `
                -CanAutoRemediate $true `
                -RemediationAction {
                    Remove-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name "AlwaysInstallElevated" -ErrorAction SilentlyContinue
                    Remove-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name "AlwaysInstallElevated" -ErrorAction SilentlyContinue
                }
        }
        
        # Check for unquoted service paths
        $services = Get-CimInstance -ClassName Win32_Service | Where-Object { 
            $_.PathName -and 
            $_.PathName -notmatch '^".*"' -and 
            $_.PathName -match ' ' -and
            $_.StartMode -ne "Disabled"
        }
        
        foreach ($service in $services) {
            Add-Vulnerability -Category "PRIVESC" -VulnID "PE-002" -Title "Unquoted Service Path: $($service.Name)" -Severity "Medium" `
                -Description "Service '$($service.Name)' has unquoted path with spaces" `
                -Impact "Potential DLL hijacking and privilege escalation" `
                -Solution "Quote the service executable path" `
                -Details @{ ServiceName = $service.Name; Path = $service.PathName }
        }
        
        # Check for weak service permissions
        $vulnerableServices = @()
        $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
        
        # This is a simplified check - in practice, you'd use more sophisticated permission analysis
        $services = Get-Service | Where-Object { $_.Status -eq "Running" -and $_.StartType -ne "Disabled" }
        foreach ($service in $services | Select-Object -First 20) {  # Limit for performance
            try {
                $serviceAcl = Get-Acl -Path "HKLM:\SYSTEM\CurrentControlSet\Services\$($service.Name)" -ErrorAction SilentlyContinue
                if ($serviceAcl) {
                    $weakPermissions = $serviceAcl.Access | Where-Object { 
                        $_.IdentityReference -match "Everyone|Users|Authenticated Users" -and 
                        $_.AccessControlType -eq "Allow" -and
                        $_.RegistryRights -match "FullControl|WriteKey"
                    }
                    
                    if ($weakPermissions) {
                        Add-Vulnerability -Category "PRIVESC" -VulnID "PE-003" -Title "Weak Service Permissions: $($service.Name)" -Severity "Medium" `
                            -Description "Service registry key has weak permissions" `
                            -Impact "Potential service configuration modification" `
                            -Solution "Review and restrict service registry permissions"
                    }
                }
            }
            catch {
                # Service registry key may not be accessible
            }
        }
        
        Write-VulnLog "Privilege escalation vulnerability check completed" "SUCCESS" "PRIVESC"
    }
    catch {
        Write-VulnLog "Error checking privilege escalation vulnerabilities: $($_.Exception.Message)" "ERROR" "PRIVESC"
    }
}

# Check for network vulnerabilities
function Test-NetworkVulnerabilities {
    Write-VulnLog "Checking for network vulnerabilities" "INFO" "NETWORK"
    
    try {
        # Check for open ports
        $dangerousPorts = @{
            21 = "FTP"
            23 = "Telnet"
            25 = "SMTP"
            53 = "DNS"
            135 = "RPC"
            139 = "NetBIOS"
            445 = "SMB"
            1433 = "SQL Server"
            1521 = "Oracle"
            3389 = "RDP"
            5985 = "WinRM HTTP"
            5986 = "WinRM HTTPS"
        }
        
        $openPorts = Get-NetTCPConnection | Where-Object { 
            $_.State -eq "Listen" -and 
            ($_.LocalAddress -eq "0.0.0.0" -or $_.LocalAddress -eq "::")
        }
        
        foreach ($port in $openPorts) {
            if ($dangerousPorts.ContainsKey($port.LocalPort)) {
                $severity = switch ($port.LocalPort) {
                    21, 23, 25, 135, 139 { "High" }
                    445, 3389 { "Medium" }
                    default { "Low" }
                }
                
                Add-Vulnerability -Category "NETWORK" -VulnID "NET-$($port.LocalPort)" -Title "Dangerous Port Open: $($port.LocalPort)" -Severity $severity `
                    -Description "Port $($port.LocalPort) ($($dangerousPorts[$port.LocalPort])) is listening on all interfaces" `
                    -Impact "Service may be accessible from untrusted networks" `
                    -Solution "Configure firewall rules or bind service to specific interfaces only"
            }
        }
        
        # Check SMBv1
        $smbv1 = Get-SmbServerConfiguration | Select-Object EnableSMB1Protocol
        if ($smbv1.EnableSMB1Protocol) {
            Add-Vulnerability -Category "NETWORK" -VulnID "NET-SMB1" -Title "SMBv1 Protocol Enabled" -Severity "Critical" `
                -Description "SMBv1 protocol is enabled (vulnerable to WannaCry and similar attacks)" `
                -Impact "System vulnerable to remote code execution attacks" `
                -Solution "Disable SMBv1 protocol immediately" `
                -CanAutoRemediate $true `
                -RemediationAction { Set-SmbServerConfiguration -EnableSMB1Protocol $false -Force }
        }
        
        # Check for weak network authentication
        $lmLevel = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name "LmCompatibilityLevel" -ErrorAction SilentlyContinue
        if ($lmLevel -and $lmLevel.LmCompatibilityLevel -lt 5) {
            Add-Vulnerability -Category "NETWORK" -VulnID "NET-AUTH" -Title "Weak Network Authentication" -Severity "High" `
                -Description "LM compatibility level allows weak authentication methods" `
                -Impact "Vulnerable to pass-the-hash and other authentication attacks" `
                -Solution "Set LmCompatibilityLevel to 5 (NTLMv2 only)" `
                -CanAutoRemediate $true `
                -RemediationAction { Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -Name "LmCompatibilityLevel" -Value 5 }
        }
        
        Write-VulnLog "Network vulnerability check completed" "SUCCESS" "NETWORK"
    }
    catch {
        Write-VulnLog "Error checking network vulnerabilities: $($_.Exception.Message)" "ERROR" "NETWORK"
    }
}

# Execute automated remediation
function Invoke-VulnerabilityRemediation {
    if (-not $AutoRemediate) {
        Write-VulnLog "Auto-remediation not enabled. Use -AutoRemediate to fix vulnerabilities automatically" "INFO" "REMEDIATION"
        return
    }
    
    Write-VulnLog "Starting automated vulnerability remediation" "INFO" "REMEDIATION"
    
    $remediatedCount = 0
    foreach ($vuln in $script:Vulnerabilities) {
        if ($vuln.CanAutoRemediate -and $vuln.RemediationAction) {
            try {
                if ($WhatIf) {
                    Write-VulnLog "WhatIf: Would remediate $($vuln.Title)" "INFO" "REMEDIATION"
                } else {
                    Write-VulnLog "Remediating: $($vuln.Title)" "INFO" "REMEDIATION"
                    & $vuln.RemediationAction
                    $remediatedCount++
                }
                
                $script:RemediationActions += [PSCustomObject]@{
                    VulnID = $vuln.VulnID
                    Title = $vuln.Title
                    Category = $vuln.Category
                    Status = if ($WhatIf) { "WhatIf" } else { "Success" }
                    Timestamp = Get-Date
                }
            }
            catch {
                Write-VulnLog "Failed to remediate $($vuln.Title): $($_.Exception.Message)" "ERROR" "REMEDIATION"
                $script:RemediationActions += [PSCustomObject]@{
                    VulnID = $vuln.VulnID
                    Title = $vuln.Title
                    Category = $vuln.Category
                    Status = "Failed"
                    Error = $_.Exception.Message
                    Timestamp = Get-Date
                }
            }
        }
    }
    
    Write-VulnLog "Vulnerability remediation completed. $remediatedCount issues $(if ($WhatIf) {'would be'} else {'were'}) fixed" "SUCCESS" "REMEDIATION"
}

# Generate vulnerability assessment report
function Generate-VulnerabilityReport {
    Write-VulnLog "Generating vulnerability assessment report" "INFO" "REPORT"
    
    $html = @"
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Assessment Report</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; background: #f0f2f5; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .dashboard { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 30px 0; }
        .metric-card { background: white; padding: 25px; border-radius: 10px; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .metric-number { font-size: 2.5em; font-weight: bold; margin-bottom: 10px; }
        .metric-label { color: #666; font-weight: 500; }
        .critical-number { color: #e74c3c; }
        .high-number { color: #f39c12; }
        .medium-number { color: #3498db; }
        .low-number { color: #27ae60; }
        .vulnerability { background: white; margin: 15px 0; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-left: 5px solid #bdc3c7; }
        .vuln-critical { border-left-color: #e74c3c; }
        .vuln-high { border-left-color: #f39c12; }
        .vuln-medium { border-left-color: #3498db; }
        .vuln-low { border-left-color: #27ae60; }
        .vuln-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .vuln-title { font-size: 1.2em; font-weight: bold; color: #2c3e50; }
        .severity-badge { padding: 5px 15px; border-radius: 20px; color: white; font-weight: bold; font-size: 0.8em; }
        .severity-critical { background-color: #e74c3c; }
        .severity-high { background-color: #f39c12; }
        .severity-medium { background-color: #3498db; }
        .severity-low { background-color: #27ae60; }
        .vuln-details { margin-top: 15px; }
        .vuln-section { margin-bottom: 10px; }
        .vuln-label { font-weight: bold; color: #34495e; }
        .remediation-table { width: 100%; background: white; border-radius: 10px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin: 20px 0; }
        .remediation-table th, .remediation-table td { padding: 15px; text-align: left; border-bottom: 1px solid #ecf0f1; }
        .remediation-table th { background: #34495e; color: white; }
        .auto-fix { color: #27ae60; font-weight: bold; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔍 Vulnerability Assessment Report</h1>
        <p>Comprehensive Security Vulnerability Analysis</p>
        <p>Generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') | Computer: $env:COMPUTERNAME</p>
    </div>
    
    <div class="dashboard">
        <div class="metric-card">
            <div class="metric-number">$($script:Vulnerabilities.Count)</div>
            <div class="metric-label">Total Vulnerabilities</div>
        </div>
        <div class="metric-card">
            <div class="metric-number critical-number">$(($script:Vulnerabilities | Where-Object Severity -eq "Critical").Count)</div>
            <div class="metric-label">Critical</div>
        </div>
        <div class="metric-card">
            <div class="metric-number high-number">$(($script:Vulnerabilities | Where-Object Severity -eq "High").Count)</div>
            <div class="metric-label">High</div>
        </div>
        <div class="metric-card">
            <div class="metric-number medium-number">$(($script:Vulnerabilities | Where-Object Severity -eq "Medium").Count)</div>
            <div class="metric-label">Medium</div>
        </div>
        <div class="metric-card">
            <div class="metric-number low-number">$(($script:Vulnerabilities | Where-Object Severity -eq "Low").Count)</div>
            <div class="metric-label">Low</div>
        </div>
        <div class="metric-card">
            <div class="metric-number" style="color: #9b59b6;">$(($script:Vulnerabilities | Where-Object CanAutoRemediate -eq $true).Count)</div>
            <div class="metric-label">Auto-Fixable</div>
        </div>
    </div>
    
    <h2>🛠️ Vulnerability Details</h2>
"@
    
    foreach ($vuln in ($script:Vulnerabilities | Sort-Object { 
        switch ($_.Severity) {
            "Critical" { 1 }
            "High" { 2 }
            "Medium" { 3 }
            "Low" { 4 }
            default { 5 }
        }
    }, Category)) {
        $severityClass = "vuln-" + $vuln.Severity.ToLower()
        $html += @"
    <div class="vulnerability $severityClass">
        <div class="vuln-header">
            <div class="vuln-title">[$($vuln.VulnID)] $($vuln.Title)</div>
            <div class="severity-badge severity-$($vuln.Severity.ToLower())">$($vuln.Severity)</div>
        </div>
        <div class="vuln-details">
            <div class="vuln-section"><span class="vuln-label">Category:</span> $($vuln.Category)</div>
            <div class="vuln-section"><span class="vuln-label">Description:</span> $($vuln.Description)</div>
            <div class="vuln-section"><span class="vuln-label">Impact:</span> $($vuln.Impact)</div>
            <div class="vuln-section"><span class="vuln-label">Solution:</span> $($vuln.Solution)</div>
            $(if ($vuln.CanAutoRemediate) { '<div class="vuln-section"><span class="auto-fix">✓ Auto-remediation available</span></div>' })
        </div>
    </div>
"@
    }
    
    if ($script:RemediationActions.Count -gt 0) {
        $html += @"
    
    <h2>🔧 Remediation Actions</h2>
    <table class="remediation-table">
        <tr>
            <th>Vulnerability ID</th>
            <th>Title</th>
            <th>Category</th>
            <th>Status</th>
            <th>Timestamp</th>
        </tr>
"@
        
        foreach ($action in $script:RemediationActions) {
            $statusClass = switch ($action.Status) {
                "Success" { "color: #27ae60;" }
                "Failed" { "color: #e74c3c;" }
                "WhatIf" { "color: #f39c12;" }
                default { "" }
            }
            
            $html += @"
        <tr>
            <td>$($action.VulnID)</td>
            <td>$($action.Title)</td>
            <td>$($action.Category)</td>
            <td style="$statusClass">$($action.Status)</td>
            <td>$($action.Timestamp.ToString('yyyy-MM-dd HH:mm:ss'))</td>
        </tr>
"@
        }
        
        $html += "</table>"
    }
    
    $html += @"
    
    <div style="background: white; padding: 20px; margin: 30px 0; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <h3>📋 Assessment Summary</h3>
        <p><strong>Risk Level:</strong> $(
            if (($script:Vulnerabilities | Where-Object Severity -eq "Critical").Count -gt 0) { "🔴 Critical - Immediate action required" }
            elseif (($script:Vulnerabilities | Where-Object Severity -eq "High").Count -gt 0) { "🟠 High - Action required soon" }
            elseif (($script:Vulnerabilities | Where-Object Severity -eq "Medium").Count -gt 0) { "🟡 Medium - Monitor and plan remediation" }
            else { "🟢 Low - Routine maintenance" }
        )</p>
        <p><strong>Next Steps:</strong> 
        $(if (($script:Vulnerabilities | Where-Object Severity -in @("Critical", "High")).Count -gt 0) {
            "Priority should be given to critical and high-severity vulnerabilities. Consider implementing automated remediation for supported issues."
        } else {
            "Continue regular security monitoring and apply updates as they become available."
        })</p>
    </div>
</body>
</html>
"@
    
    $html | Out-File -FilePath $ReportPath -Encoding UTF8
    Write-VulnLog "Vulnerability assessment report generated: $ReportPath" "SUCCESS" "REPORT"
    return $ReportPath
}

# Main execution function
function Start-VulnerabilityAssessment {
    $script:AssessmentStartTime = Get-Date
    
    Write-VulnLog "Starting Comprehensive Vulnerability Assessment" "INFO" "MAIN"
    Write-VulnLog "Computer: $env:COMPUTERNAME | User: $env:USERNAME" "INFO" "MAIN"
    Write-VulnLog "Parameters: MinimumSeverity=$MinimumSeverity, AutoRemediate=$($AutoRemediate.IsPresent), DetailedScan=$($DetailedScan.IsPresent)" "INFO" "MAIN"
    
    try {
        # Execute vulnerability checks
        Test-WindowsVulnerabilities
        Test-SoftwareVulnerabilities
        Test-CryptographicVulnerabilities
        Test-PrivilegeEscalationVulnerabilities
        Test-NetworkVulnerabilities
        
        # Filter by minimum severity
        if ($MinimumSeverity -ne "All") {
            $severityOrder = @{ "Critical" = 4; "High" = 3; "Medium" = 2; "Low" = 1 }
            $minLevel = $severityOrder[$MinimumSeverity]
            $script:Vulnerabilities = $script:Vulnerabilities | Where-Object { 
                $severityOrder[$_.Severity] -ge $minLevel 
            }
        }
        
        # Execute remediation if requested
        if ($AutoRemediate -or $WhatIf) {
            Invoke-VulnerabilityRemediation
        }
        
        # Generate comprehensive report
        $reportPath = Generate-VulnerabilityReport
        
        # Summary
        $duration = (Get-Date) - $script:AssessmentStartTime
        Write-VulnLog "Vulnerability assessment completed in $($duration.ToString('hh\:mm\:ss'))" "SUCCESS" "MAIN"
        Write-VulnLog "Total vulnerabilities found: $($script:Vulnerabilities.Count)" "INFO" "MAIN"
        Write-VulnLog "Report generated: $reportPath" "INFO" "MAIN"
        
        # Return results for Nexthink
        $output = @{
            Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ss.fffZ"
            Success = $true
            TotalVulnerabilities = $script:Vulnerabilities.Count
            CriticalVulnerabilities = ($script:Vulnerabilities | Where-Object Severity -eq "Critical").Count
            HighVulnerabilities = ($script:Vulnerabilities | Where-Object Severity -eq "High").Count
            MediumVulnerabilities = ($script:Vulnerabilities | Where-Object Severity -eq "Medium").Count
            LowVulnerabilities = ($script:Vulnerabilities | Where-Object Severity -eq "Low").Count
            AutoRemediableCount = ($script:Vulnerabilities | Where-Object CanAutoRemediate -eq $true).Count
            RemediationActions = $script:RemediationActions.Count
            AssessmentDuration = $duration.TotalMinutes
            ReportPath = $reportPath
            LogPath = $LogPath
        } | ConvertTo-Json -Compress
        
        Write-Host "NEXTHINK_OUTPUT: $output"
        
        # Exit code based on vulnerability severity
        $criticalCount = ($script:Vulnerabilities | Where-Object Severity -eq "Critical").Count
        $highCount = ($script:Vulnerabilities | Where-Object Severity -eq "High").Count
        
        if ($criticalCount -gt 0) {
            exit 2  # Critical vulnerabilities found
        } elseif ($highCount -gt 0) {
            exit 1  # High severity vulnerabilities found
        } else {
            exit 0  # Clean or low-risk findings only
        }
    }
    catch {
        Write-VulnLog "Critical error during vulnerability assessment: $($_.Exception.Message)" "ERROR" "MAIN"
        
        $errorOutput = @{
            Timestamp = Get-Date -Format "yyyy-MM-ddTHH:mm:ss.fffZ"
            Success = $false
            Error = $_.Exception.Message
            LogPath = $LogPath
        } | ConvertTo-Json -Compress
        
        Write-Host "NEXTHINK_OUTPUT: $errorOutput"
        exit 1
    }
}

# Execute if script is run directly
if ($MyInvocation.InvocationName -ne '.') {
    Start-VulnerabilityAssessment
}
